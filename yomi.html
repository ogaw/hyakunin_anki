<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>百人一首 読み上げツール</title>
  <style>
    :root{
      --bg:#0b0c10;
      --card:#141824;
      --card2:#101420;
      --text:#e9ecf1;
      --muted:#a8b0c2;
      --accent:#5dd6ff;
      --danger:#ff5d6c;
      --ok:#56f39a;
      --border:rgba(255,255,255,.10);
      --shadow:0 10px 30px rgba(0,0,0,.35);
      --radius:16px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", "Hiragino Kaku Gothic ProN", Meiryo, sans-serif;
      background: radial-gradient(1200px 800px at 20% 0%, rgba(93,214,255,.14), transparent 55%),
                  radial-gradient(1000px 700px at 90% 20%, rgba(255,93,108,.10), transparent 55%),
                  var(--bg);
      color:var(--text);
    }
    .wrap{
      max-width: 760px;
      margin: 0 auto;
      padding: 14px 14px 26px;
      padding-bottom: calc(26px + env(safe-area-inset-bottom));
    }
    .topbar{
      position: sticky;
      top: 0;
      z-index: 10;
      padding: 12px 0 10px;
      backdrop-filter: blur(10px);
      background: linear-gradient(to bottom, rgba(11,12,16,.92), rgba(11,12,16,.55), transparent);
    }
    .panel{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
    }
    .controls{
      padding: 12px;
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
    }
    .btnrow{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 10px;
    }
    button{
      appearance:none;
      border:none;
      border-radius: 14px;
      padding: 14px 10px;
      font-weight: 800;
      font-size: 16px;
      color: var(--text);
      background: rgba(255,255,255,.10);
      border: 1px solid rgba(255,255,255,.14);
      box-shadow: 0 8px 18px rgba(0,0,0,.22);
      transition: transform .04s ease, filter .12s ease, opacity .12s ease;
      touch-action: manipulation;
    }
    button:active{ transform: translateY(1px) scale(.99); }
    button:disabled{ opacity: .45; }
    .btn-start{ background: rgba(93,214,255,.18); border-color: rgba(93,214,255,.35); }
    .btn-pause{ background: rgba(255,255,255,.10); }
    .btn-next { background: rgba(255,255,255,.10); }
    .btn-reset{ background: rgba(255,93,108,.16); border-color: rgba(255,93,108,.30); }
    .status{
      padding: 10px 12px 12px;
      display:flex;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
      border-top: 1px solid var(--border);
      color: var(--muted);
      font-size: 13px;
    }
    .badge{
      font-size: 12px;
      font-weight: 700;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(0,0,0,.18);
      color: var(--text);
      white-space: nowrap;
    }
    .badge.ok{ border-color: rgba(86,243,154,.35); background: rgba(86,243,154,.12); }
    .badge.warn{ border-color: rgba(255,93,108,.35); background: rgba(255,93,108,.12); }
    .badge.info{ border-color: rgba(93,214,255,.35); background: rgba(93,214,255,.12); }

    .settings{
      margin-top: 12px;
      padding: 14px;
    }
    .h{
      font-size: 14px;
      letter-spacing: .02em;
      color: var(--text);
      font-weight: 800;
      margin: 0 0 10px;
    }
    .grid{
      display:grid;
      grid-template-columns: 1fr;
      gap: 10px;
    }
    .row{
      display:grid;
      grid-template-columns: 1fr;
      gap: 8px;
      padding: 10px 10px;
      border-radius: 14px;
      background: rgba(0,0,0,.18);
      border: 1px solid var(--border);
    }
    label{
      font-size: 13px;
      color: var(--muted);
      font-weight: 700;
    }
    input[type="text"], input[type="number"]{
      width: 100%;
      padding: 12px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: var(--text);
      font-size: 16px;
      outline: none;
    }
    input[type="number"]{ -moz-appearance:textfield; }
    input[type="number"]::-webkit-outer-spin-button,
    input[type="number"]::-webkit-inner-spin-button{ -webkit-appearance: none; margin: 0; }
    .help{
      font-size: 12px;
      color: rgba(233,236,241,.65);
      line-height: 1.35;
    }
    .two{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    .mono{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12px;
      color: rgba(233,236,241,.75);
      word-break: break-all;
    }

    /* 履歴 */
    .history{
      margin-top: 12px;
      padding: 14px;
    }
    .histBox{
      border: 1px solid var(--border);
      background: rgba(0,0,0,.18);
      border-radius: 14px;
      overflow: hidden;
    }
    .histList{
      max-height: 46vh; /* スマホで見やすい */
      overflow: auto;
      -webkit-overflow-scrolling: touch;
    }
    .histItem{
      padding: 10px 10px;
      border-top: 1px solid rgba(255,255,255,.06);
      font-size: 14px;
      line-height: 1.35;
    }
    .histItem:first-child{ border-top: none; }
    .histTop{
      display:flex;
      gap: 10px;
      align-items: baseline;
      justify-content: space-between;
      margin-bottom: 10px;
      color: rgba(233,236,241,.85);
    }
    .pill{
      font-size: 12px;
      font-weight: 700;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      color: rgba(233,236,241,.9);
      white-space: nowrap;
    }
    .footer{
      margin-top: 10px;
      color: rgba(233,236,241,.55);
      font-size: 12px;
      line-height: 1.4;
    }
    @media (max-width: 420px){
      .btnrow{ grid-template-columns: 1fr; }
      button{ font-size: 18px; padding: 16px 12px; }
      .two{ grid-template-columns: 1fr; }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="topbar">
      <div class="panel controls">
        <div class="btnrow">
          <button id="btnStart" class="btn-start">開始</button>
          <button id="btnPause" class="btn-pause" disabled>一時停止</button>
           <button id="btnNext" class="btn-next"  disabled>次の歌</button>
          <button id="btnReset" class="btn-reset" disabled>終了（やり直し）</button>
        </div>
        <div class="status">
          <div>
            <div id="nowLine" style="color:var(--text);font-weight:800;font-size:14px;">待機中</div>
            <div id="subLine" style="margin-top:2px;">序歌 → ランダム（重複なし）</div>
          </div>
          <div id="stateBadge" class="badge info">STOP</div>
        </div>
      </div>
    </div>

    <div class="panel settings">
      <div class="h">設定（途中で変更OK）</div>

      <div class="grid">
        <div class="row">
          <label>読手選択</label>
          <select id="audioFolder" style="
              width:100%; padding:12px 12px; border-radius:12px;
              border:1px solid rgba(255,255,255,.14);
              background:rgba(255,255,255,.06); color:var(--text);
              font-size:16px; outline:none;">
            <option value="sgymk">杉山啓A級読手(わすらもち)</option>
            <option value="ai_kiritan">AIきりたん</option>
          </select>
        </div>
        <div class="row two">
          <div>
            <label>再生速度</label>
            <input id="playRate" type="number" step="0.05" min="0.25" max="4.0" value="1.00" />
            <div class="help">0.25~4.00（途中変更可）</div>
          </div>
          <div>
            <label>下の句を読む回数</label>
            <input id="lowerRepeat" type="number" step="1" min="1" max="2" value="1" />
            <div class="help">1 or 2（途中変更可）</div>
          </div>
        </div>

        <div class="row two">
          <div>
            <label>上の句→下の句の間（ミリ秒）</label>
            <input id="gapUpperLower" type="number" step="50" min="0" max="60000" value="800" />
          </div>
          <div>
            <label>下の句→次の上の句の間（ミリ秒）</label>
            <input id="gapLowerNext" type="number" step="50" min="0" max="60000" value="1200" />
          </div>
        </div>

        <!-- ここにラジオボタン/追加設定を増やしていく想定 -->
        <div class="row">
          <div class="help">
            <div>1周にかかる時間（概算）：<span id="cycleTimeLine" class="mono">-</span></div>
            履歴：<span id="histLine" class="mono">0 / 100</span>
          </div>
        </div>
      </div>
    </div>

    <div class="panel history">
      <div class="histTop">
        <div class="h" style="margin:0;">詠んだ札（履歴）</div>
        <div class="pill">下に追加される</div>
      </div>
      <div class="histBox">
        <div id="histList" class="histList"></div>
      </div>
      <div class="footer">
        表示形式：<span class="mono">順番   No   上の句  下の句</span>（yomi_kami / yomi_shimo）
      </div>
    </div>

  </div>

  <!-- cards.js を読み込む（index.html と同じ階層想定） -->
  <script src="./cards.js"></script>

<script>
(() => {
  // cards.js の存在チェック（ロード失敗時に即わかるように）
  if (typeof CARDS === "undefined" || !Array.isArray(CARDS)) {
    alert("cards.js が読み込めていない。index.html と同じ階層に cards.js を置いてリロードして。");
    return;
  }

  const $ = (id) => document.getElementById(id);
  const pad3 = (n) => String(n).padStart(3, "0");

  function clampInt(v, min, max, fallback){
    const x = Number.parseInt(v, 10);
    if (Number.isNaN(x)) return fallback;
    return Math.min(max, Math.max(min, x));
  }
  function clampFloat(v, min, max, fallback){
    const x = Number.parseFloat(v);
    if (Number.isNaN(x)) return fallback;
    return Math.min(max, Math.max(min, x));
  }


  // ==========
  // Guard (stop/pause management)
  // ==========
  class RunGuard {
    constructor(){
      this._stopped = true;
      this._paused = false;
      this._pauseWaiters = [];
    }
    start(){
      this._stopped = false;
      this._paused = false;
      this._releasePauseWaiters();
    }
    stop(){
      this._stopped = true;
      this._paused = false;
      this._releasePauseWaiters();
    }
    pause(){
      if (this._stopped) return;
      this._paused = true;
    }
    resume(){
      if (this._stopped) return;
      this._paused = false;
      this._releasePauseWaiters();
    }
    get stopped(){ return this._stopped; }
    get paused(){ return this._paused; }

    throwIfStopped(){
      if (this._stopped) throw new Error("STOPPED");
    }
    waitIfPaused(){
      if (!this._paused) return Promise.resolve();
      return new Promise(resolve => this._pauseWaiters.push(resolve));
    }
    _releasePauseWaiters(){
      const ws = this._pauseWaiters;
      this._pauseWaiters = [];
      ws.forEach(r => r());
    }
  }


  // ==========
  // skip
  // ==========
  let skipRequested = false;
  let skipGen = 0;
  const SKIP_WAIT_MS = 1000;

  function requestSkip(){
    skipGen++;
    audio.pause();
  }

  async function waitMs(ms, guard, myGen){
    let remain = ms;
    const chunk = 200;
    while (remain > 0) {
      guard.throwIfStopped();
      await guard.waitIfPaused();
      if (skipGen !== myGen) return false; // 中断
      const step = Math.min(chunk, remain);
      await new Promise(r => setTimeout(r, step));
      remain -= step;
    }
    return true;
  }


  // ==========
  // Audio player
  // ==========
  const audio = new Audio();
  audio.preload = "auto";

  function buildPath(folder, nnn, m){
    // 「アプリルート/音声フォルダ名/音声データ名_nnn_m.ogg」
    return `./${folder}/${folder}_${nnn}_${m}.ogg`;
  }
  // ===== 履歴（画面下に1行ずつ追加） =====
  let done = 0; // 「詠んだ順番」カウンタ（001?100のみをカウント）
  function appendHistoryLine(no){
    const list = $("histList");
    const card = (typeof CARD_BY_NO !== "undefined") ? CARD_BY_NO.get(no) : null;

    const order = done; // done は increment後に呼ぶ想定
    const noTxt = String(no);
    const kami = card?.yomi_kami ?? "(yomi_kamiなし)";
    const shimo = card?.yomi_shimo ?? "(yomi_shimoなし)";

    const div = document.createElement("div");
    div.className = "histItem";
    div.textContent = `${order} 　　 ${noTxt}番　　${kami}　　${shimo}`;

    list.appendChild(div);
    // 一番下に自動スクロール（新規追加が見える）
    list.scrollTop = list.scrollHeight;
  }

  async function playFile(src, guard, myGen){
    guard.throwIfStopped();
    await guard.waitIfPaused();

    audio.pause();

    // iOSでたまに必要になるのでロードを促す（失敗しても継続）
    try { audio.load(); } catch(_){}

    audio.currentTime = 0;
    audio.src = src;
    audio.playbackRate = getSettings().playRate;


    // 再生中に設定変更があったら追従（rateのみ）
    const onRate = () => {
      const v = parseFloat($("playRate").value);
      if (!Number.isFinite(v)) return;      // 空/不正の瞬間は上書きしない
      audio.playbackRate = v;
    };
    
    
    $("playRate").addEventListener("input", onRate);

    try{
      await audio.play(); // ユーザー操作無しだと弾かれる可能性あり
    } catch (e){
      $("playRate").removeEventListener("input", onRate);
      throw e;
    }

    return await new Promise((resolve, reject) => {
      let is_done = false;
      const cleanup = () => {
        if (is_done) return;
        is_done = true;
        audio.removeEventListener("ended", onEnded);
        audio.removeEventListener("error", onError);
        $("playRate").removeEventListener("input", onRate);
      };

      const onEnded = () => { cleanup(); resolve(true); };
      const onError = () => { cleanup(); reject(new Error("AUDIO_ERROR")); };

      audio.addEventListener("ended", onEnded, { once:true });
      audio.addEventListener("error", onError, { once:true });

      (async () => {
        while (!is_done) {
          if (guard.stopped) { cleanup(); reject(new Error("STOPPED")); return; }
          if (skipGen !== myGen) { cleanup(); resolve(false); return; } // 中断
          if (guard.paused && !audio.paused) audio.pause();
          if (!guard.paused && audio.paused) { try { await audio.play(); } catch(_){} }
          await new Promise(r => requestAnimationFrame(r));
        }
      })();
    });
  }

  // ==========
  // Random non-duplicate deck
  // ==========
  function shuffledArray(arr){
    const a = arr.slice();
    for (let i = a.length - 1; i > 0; i--){
      const j = Math.floor(Math.random() * (i + 1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }

  class Deck {
    constructor(){
      this.reset();
    }
    reset(){
      // 001?100（序歌000は別扱い）
      this.remaining = shuffledArray([...Array(100)].map((_,i)=> i+1));
      this.history = [];
    }
    next(){
      if (this.remaining.length === 0){
        // 1周しきったら、また全曲をシャッフルして継続
        this.remaining = shuffledArray(this.history);
        this.history = [];
      }
      const v = this.remaining.pop();
      this.history.push(v);
      return v;
    }
    get doneCount(){
      return this.history.length;
    }
  }

  // ==========
  // Settings getter
  // ==========
  function getSettings(){
    return {
      folder: $("audioFolder").value.trim() || "audio",
      playRate: clampFloat($("playRate").value, 0.25, 4.0, 1.0),
      lowerRepeat: clampInt($("lowerRepeat").value, 1, 2, 1),
      gapUpperLower: clampInt($("gapUpperLower").value, 0, 60000, 800),
      gapLowerNext: clampInt($("gapLowerNext").value, 0, 60000, 1200),
    };
  }

  // ==========
  // UI state
  // ==========
  function setBadge(kind, text){
    const b = $("stateBadge");
    b.className = "badge " + kind;
    b.textContent = text;
  }
  function setNow(main, sub){
    $("nowLine").textContent = main;
    $("subLine").textContent = sub || "";
  }
  function setFileLine(s){
    $("fileLine").textContent = s || "-";
  }
  function setHistLine(done, total){
    $("histLine").textContent = `${done} / ${total}`;
  }

  function formatMinSec(totalSec){
    totalSec = Math.max(0, Math.round(totalSec));
    const m = Math.floor(totalSec / 60);
    const s = totalSec % 60;
    return `${m}分${String(s).padStart(2,"0")}秒`;
  }

  // ogg総再生秒数（序歌含む・上下句1回ずつの合計）
  const AUDIO_SUM_SEC = {
    sgymk: 1706,
    ai_kiritan: 1754,
  };

  // ogg総再生秒数（序歌含む）
  // ※あとで実測値を入れ替える前提：上の句合計 / 下の句合計
  const AUDIO_SUM_KAMI_SEC = {
    sgymk: 818,        // TODO: 上の句合計（序歌000含む）
    ai_kiritan: 971,   // TODO
  };

  const AUDIO_SUM_SHIMO_SEC = {
    sgymk: 888,        // TODO: 下の句合計（序歌000含む）
    ai_kiritan: 783,   // TODO
  };


  // 1周=「序歌(000) + 100首」なので 101回ぶん
  const CYCLE_COUNT = 101;

  function updateCycleTimeUI(){
    const s = getSettings();
    const kami = AUDIO_SUM_KAMI_SEC[s.folder] ?? 0;
    const shimo = AUDIO_SUM_SHIMO_SEC[s.folder] ?? 0;

    // lowerRepeat は「下の句を合計で何回読むか」なので、そのまま掛ける
    const audioBaseSec = kami + shimo * s.lowerRepeat;

    // 音声は再生速度の逆数でスケール
    const audioSec = audioBaseSec / s.playRate;

    // ウェイトは固定時間×回数（ms→sec）
    const waitSec = (s.gapUpperLower + s.gapLowerNext) * CYCLE_COUNT / 1000;

    const total = audioSec + waitSec;

    const el = document.getElementById("cycleTimeLine");
    if (el) el.textContent = `${formatMinSec(total)}（音声${formatMinSec(audioSec)} + 待ち${formatMinSec(waitSec)}）`;
  }

  // ==========
  // Main run loop
  // ==========
  const guard = new RunGuard();
  const deck = new Deck();

  let runningPromise = null;

  async function run(){
    const s0 = getSettings();

    // 序歌 000（上の句→下の句）だけ先に
    await playKamiShimo(0);

    // 以降、ランダム（重複なし）
    while(done < 100){
      guard.throwIfStopped();
      const n = deck.next();
      setHistLine(deck.doneCount, 100);
      const ok = await playKamiShimo(n);

      // 履歴を追加（「詠んだ札」＝1..100）
      done += 1;
      appendHistoryLine(n);

      // 進捗表示（100周で 100/100）
      setHistLine(done, 100);

      if (!ok){
        await new Promise(r => setTimeout(r, SKIP_WAIT_MS));
      }

    }
    
    setBadge("info", "STOP");
    setNow("終了", "100首読み終わりました");
    guard.stop();
  }


  async function playKamiShimo(num){
    const myGen = skipGen;                 // この歌の世代を固定
    const s = getSettings();
    const nnn = pad3(num);

    const up = buildPath(s.folder, nnn, 1);
    const ok1 = await playFile(up, guard, myGen);
    if (!ok1) return false;

    const okGap1 = await waitMs(s.gapUpperLower, guard, myGen);
    if (!okGap1) return false;

    const low = buildPath(s.folder, nnn, 2);
    for (let k=1; k<=s.lowerRepeat; k++){
      const ok2 = await playFile(low, guard, myGen);
      if (!ok2) return false;
    }

    const okGap2 = await waitMs(s.gapLowerNext, guard, myGen);
    if (!okGap2) return false;

    return true;
  }

  // ==========
  // Buttons
  // ==========
  function setButtons(){
    $("btnStart").disabled = !guard.stopped; // 実行中は開始無効
    $("btnPause").disabled = guard.stopped;
    $("btnReset").disabled = guard.stopped;
    $("btnNext").disabled  = guard.stopped;
    $("btnPause").textContent = guard.paused ? "再開" : "一時停止";
  }

  $("btnStart").addEventListener("click", async () => {
    if (!guard.stopped) return;

    // 初回はデッキを初期化（やり直し時もここ）
    deck.reset();
    setHistLine(0, 100);
    done = 0;
    document.getElementById("histList").innerHTML = "";

    guard.start();
    setBadge("ok", "RUN");
    setNow("準備中…", "序歌を再生します");
    setButtons();

    runningPromise = (async () => {
      try{
        await run();
      } catch(e){
        // STOPPED は正常終了扱い
        if (String(e?.message) !== "STOPPED"){
          console.error(e);
          setBadge("warn", "ERROR");
          setNow("エラー", "音声ファイルのパス/命名を確認してね");
        }
      } finally {
        // stopが呼ばれてなければ止める
        if (!guard.stopped) guard.stop();
        audio.pause();
        audio.currentTime = 0;
        setButtons();
        if (guard.stopped && $("stateBadge").textContent === "RUN"){
          setBadge("info", "STOP");
          setNow("停止中", "開始で最初から");
        }
      }
    })();
  });

  $("btnPause").addEventListener("click", () => {
    if (guard.stopped) return;
    if (!guard.paused){
      guard.pause();
      setBadge("info", "PAUSE");
      setNow("一時停止中", "再開で続き");
    } else {
      guard.resume();
      setBadge("ok", "RUN");
      // nowLineは次の更新で上書きされる
    }
    setButtons();
  });
  
  $("btnNext").addEventListener("click", () => {
    if (guard.stopped) return;
    requestSkip();
  });

  $("btnReset").addEventListener("click", () => {
    if (guard.stopped) return;
    guard.stop();
    audio.pause();
    audio.currentTime = 0;
    setBadge("info", "STOP");
    setNow("停止中", "開始で最初から");
    setFileLine("-");
    setButtons();
  });

  // 設定が不正値にならないよう軽く矯正（入力中は邪魔しない）
  ["playRate","lowerRepeat","gapUpperLower","gapLowerNext"].forEach(id => {
    $(id).addEventListener("change", () => {
      const s = getSettings();
      $("playRate").value = s.playRate.toFixed(2);
      $("lowerRepeat").value = String(s.lowerRepeat);
      $("gapUpperLower").value = String(s.gapUpperLower);
      $("gapLowerNext").value = String(s.gapLowerNext);
      updateCycleTimeUI();
    });
  });
  $("audioFolder").addEventListener("change", updateCycleTimeUI);
  $("playRate").addEventListener("input", updateCycleTimeUI);
  $("gapUpperLower").addEventListener("input", updateCycleTimeUI);
  $("gapLowerNext").addEventListener("input", updateCycleTimeUI);
  $("lowerRepeat").addEventListener("input", updateCycleTimeUI);



  // 初期UI
  setButtons();
  setHistLine(0, 100);
  updateCycleTimeUI();
})();
</script>
</body>
</html>
